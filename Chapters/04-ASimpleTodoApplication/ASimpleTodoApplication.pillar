!! A Simple ToDo Application

The objective of this chapter is to highlight the important issues when building a Seaside application: defining a model, defining a component, rendering the component, adding callbacks, and calling other components. This chapter will repeat some elements already presented before but within the context of a little application. It is a kind of summary of the previous points.


!!! Defining a Model

It is a good software engineering practice to clearly separate the domain from its views. This is a common practice which allows one to change the rendering or even the rendering framework without having to deal with the internal aspects of the model. Thus, we will begin by presenting a simple model for a todo list that contains todo items as shown by Figure *@fig:todoUML*.

+A simple model with items and an item container.>file://figures/todoUML.png|width=70|label=fig:todoUML+

""==ToDoItem== class."" A todo item is characterized by a title, a due date and a status which indicates whether the item is done.

[[[
Object subclass: #ToDoItem
    instanceVariableNames: 'title due done'
    classVariableNames: ''
    package: 'ToDo-Model'
]]]

It has accessor methods for the instance variables ==title==, ==due== and ==done==.

[[[
ToDoitem >> title
    ^ title
]]]
[[[
ToDoitem >> title: aString
    title := aString
]]]
[[[
ToDoItem >> due
    ^ due
]]]
[[[
ToDoItem >> due: aDate
    due := aDate asDate
]]]
[[[
ToDoItem >> done
    ^ done
]]]
[[[
ToDoItem >> done: aBoolean
    done := aBoolean
]]]

We specify the default values when a new todo item is created by defining a method ==initialize== as follows:

[[[
ToDoItem >> initialize
    self title: 'ToDo Item'.
    self due: Date tomorrow.
    self done: false.
]]]


@@note ""A word about ==initialize== and ==new==."" Pharo and Squeak are the only Smalltalk dialect that performs automatic object initialization. This greatly simplifies the definition of classes. If you have defined an ==initialize== method, it will be automatically called when you send the message ==new== to your classes. In addition, the method ==initialize== is defined in the class ==Object== so you can (and are encouraged) to invoke potential ==initialize== methods of your superclasses using ==super initialize== in your own ==initialize== method. If you want to write code that is portable between dialects, you should redefine the method ==new== in all your root classes (subclasses of ==Object==) as shown below and you should ""not"" invoke ==initialize== via a super call in your root classes.

[[[
ToDoItem class >> new
    ^ self basicNew initialize
]]]

In this book we follow this convention and this is why we have not added ==super initialize== in the methods ==ToDoItem>>initialize== and ==ToDoList>>initialize==.

We also add two testing methods to our todo item:

[[[
ToDoItem >> isDone
    ^ self done
]]]
[[[
ToDoItem >> isOverdue
    ^ self isDone not and: [ Date today > self due ]
]]]


""==ToDoList== Class."" We now create a class that will hold a list of todo items. The instance variables will contain a title and a list of items. In addition, we define a ''class variable'' ==Default== that will refer to a singleton of our class.

[[[
Object subclass: #ToDoList
   instanceVariableNames: 'title items'
    classVariableNames: 'Default'
    package: 'ToDo-Model'
]]]

You should next add the associated accessor methods ==title==, ==title:==, ==items== and ==items:==. 

The instance variable ==items== is initialized with an ==OrderedCollection== in the ==initialize== method:

[[[
ToDoList >> initialize
   self items: OrderedCollection new
]]]

We define two methods to add and remove items.

[[[
ToDoList >> add: aTodoItem
    self items add: aTodoItem
]]]
[[[
ToDoList >> remove: aTodoItem
   ^ self items remove: aTodoItem
]]]

Now we define the ''class-side'' method ==default== that implements a lazy initialization of the singleton, initializes it with some examples and returns it. The class-side method ==reset== will reset the singleton if necessary.

[[[
ToDoList class >> default
    ^ Default ifNil: [ Default := self new ]
]]]
[[[
ToDoList class >> reset
   Default := nil
]]]

Finally, we define a method to add some todo items to our application so that we have some items to work with. 

[[[
ToDoList class >> initializeExamples
    "self initializeExamples"

    self default
        title: 'Seaside ToDo';
        add: (ToDoItem new
            title: 'Finish todo app chapter';
            due: '11/15/2007' asDate;
            done: false);
        add: (ToDoItem new
            title: 'Annotate first chapter';
            due: '04/21/2008' asDate;
            done: true);
         add: (ToDoItem new
            title: 'Watch out for UNIX Millenium bug';
            due: '01/19/2038' asDate;
            done: false)
]]]

Now evaluate this method (by selecting the ==self initializeExamples== text and selecting ==do it== from the context menu). This will populate our model with some default todo items.

Now we are ready to define our seaside application using this model.

!!! Defining a View

First, we define a component to see the item list. For that, we define a new component named ==ToDoListView==. 

[[[
WAComponent subclass: #ToDoListView
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'ToDo-View'
]]]

We can register the application by defining the class method initialize as shown and by executing ToDoListView>>initialize.

[[[
ToDoListView class >> initialize
    "self initialize"
    WAAdmin register: self asApplicationAt: 'todo'
]]]

You can see that the todo application is now registered by pointing your browser to *http://localhost:8080/config/* as shown in *@fig:todoregistered*.

+ The application is registered in Seaside (sd).>file://figures/todoregistered.png|width=40|label=fig:todoregistered+

If you click on the todo link in the config list you will get an empty browser window. This is to be expected since so far the application does not do any rendering. Now if you click on the halo you should see that your application is present on the page as shown in *@fig:halosonemptytodo*.

+ Our application is there, but nothing is rendered.>file://figures/halosOnEmptyTodo.png|width=70|label=fig:halosonemptytodo+

Now we are ready to work on the rendering of our component.


!!! Rendering and Brushes

We define the method ==model== to access the singleton of ==ToDoList== as follows.

[[[
ToDoListView >> model
    ^ ToDoList default
]]]

@@note ""A word about design."" Note that directly accessing a singleton instead of using an instance variable is definitively not a good design since it favors procedural-like global access over encapsulation and distribution of knowledge. Here we use it because we want to produce a running application quickly. The singleton design pattern looks trivial but it is often misunderstood: it should be used when you want to ensure that there is never more than one instance; it does ""not"" limit ''access'' to one instance at a time. In general, if you can avoid a singleton by adding an instance variable to an object, then you do not need the singleton.

The method ==renderContentOn:== is called by Seaside to render a component. We will now begin to implement this method. First we just display the title of our todo list by defining the method as follows:

[[[
ToDoListView >> renderContentOn: html
   html text: self model title
]]]


If you refresh your browser you should obtain *@fig:todoWithTitle*.

+Our todo application simply displaying its title.>file://figures/todoWithTitle.png|width=70|label=fig:todoWithTitle+
   
Now we will make some changes that will help us render the list and its elements. We will define a CSS style so we redefine the method ==renderContentOn:== to use the brush ==heading==.

[[[
ToDoListView >> renderContentOn: html
    html heading: self model title
]]]

Refresh your browser to see that you did not change much, except that you will get a bigger title. To render a list of items we define a method ==renderItemsOn:== that we will invoke from ==renderContentOn:==. To render an individual item we define a method called ==renderItem:on:==.

[[[
ToDoListView >> renderItem: anItem on: html
    html listItem
        class: 'done' if: anItem isDone;
        class: 'overdue' if: anItem isOverdue;
        with: anItem title
]]]

[[[
ToDoListView >> renderItemsOn: html
    self model items
        do: [ :each | self renderItem: each on: html ]
]]]


[[[
ToDoListView >> renderContentOn: html
    html heading: self model title.
    html unorderedList: [ self renderItemsOn: html ]
]]]




As you see, we are rendering the todo items as an unordered list. We also conditionally assign CSS classes to each list item, depending on its state. To do this, we will use the handy method ==class:if:== since it allows us to write the condition and the class name in the cascade of the brush. Each item will get a class that indicates whether it is completed or overdue. The CSS will cause each item to be displayed with a color determined by its class. Because we haven't defined any CSS yet, if you refresh your browser now, you will see the plain list. 

Next, we edit the style of this component either by clicking on the halos and the pencil and editing the style directly, or by defining the method ==style== on the class ==ToDoListView== in your code browser. Check *ref:/book/fundamentals/css* to learn more about the use of style-sheets and CSS classes.

[[[
ToDoListView >> style
    ^ 'body {
    color: #222;
    font-size: 75%;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
h1 {
    color: #111;
    font-size: 2em;
    font-weight: normal;
    margin-bottom: 0.5em;
}
ul {
    list-style: none;
    padding-left: 0;
    margin-bottom: 1em;
}
li.overdue {
    color: #8a1f11;
}
li.done {
    color: #264409;
}'
]]]

Refresh your browser and you should see the list of items and the todo list title as shown in *ref:todoWithItems*.

+ Our todo application, displaying its title and a list of its items colored according to status.>file://figures/todoWithItems.png|width=70|label=fig:todoWithItems+


!!! Adding Callbacks

As we saw in *ref:/book/fundamentals/anchors*, Seaside offers a powerful way to define a user action: ''callbacks''. We can use callbacks to make our items editable. We will extend the method ==renderItem:on:== with ''edit'' and ''remove'' actions. To do this, we render two additional links with every item.

[[[
ToDoListView >> renderItem: anItem on: html
    html listItem
        class: 'done' if: anItem isDone;
        class: 'overdue' if: anItem isOverdue;
        with: [
            html text: anItem title.
            html space.
            html anchor
                callback: [ self edit: anItem ];
                with: 'edit'.
            html space.
            html anchor
                callback: [ self remove: anItem ];
                with: 'remove' ]
]]]

We use an ==anchor== brush and we attach a callback to the anchor. Thus, the methods defined below are invoked when the user clicks on an anchor. Note that we haven't implemented the edit action yet. For now, we just display the item title to see that everything is working. The remove action is fully implemented.

[[[
ToDoListView >> edit: anItem
    self inform: anItem title
]]]

[[[
ToDoListView >> remove: anItem
    (self confirm: 'Are you sure you want to remove ' , anItem title printString , '?')
        ifTrue: [ self model remove: anItem ]
]]]
	
You should now be able to click on the links attached to an item to invoke the ==edit== and ==remove== methods as shown in  *ref:todoWithAnchors*. 

+Our todo application with anchors.>file://figures/todoWithAnchors.png|width=70|label=fig:todoWithAnchors+



You can have a look at the generated XHTML code by turning on the halos and selecting the ''source'' link. You will see that Seaside is automatically adding lots of information to the links on the page. This is part of the magic of Seaside which frees you from the need to do complex request parsing and figure out what context you were in when defining the callback.

Now it would be good to allow users to add a new item. The following code will just add a new anchor under the title (see *ref:todoWithAdd*): 

[[[
ToDoListView >> renderContentOn: html
    html heading: self model title.
    html anchor 
        callback: [ self add ];
        with: 'add'.
    html unorderedList: [ self renderItemsOn: html ]
]]]


For now, we will define a basic version of the addition behavior by simply defining ==add== as the addition of the new item in the list of items. Later on we will open an editor to let the user define new todo items in place. 

[[[
ToDoListView>>add
    self model add: (ToDoItem new)
]]]

+Our todo application with add functionality.>file://figures/todoWithAdd.png|width=70|label=fig:todoWithAdd+


